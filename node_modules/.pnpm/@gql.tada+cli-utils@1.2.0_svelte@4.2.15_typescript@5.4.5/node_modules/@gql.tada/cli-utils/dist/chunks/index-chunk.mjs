import * as e from "node:fs/promises";

import * as t from "node:path";

import { isMainThread as r, parentPort as n, Worker as a, SHARE_ENV as i } from "node:worker_threads";

var s = {};

var f = {};

var o = {};

Object.defineProperty(o, "__esModule", {
  value: !0
});

o.binarySearch = void 0;

o.binarySearch = function binarySearch$2(e, t) {
  var r = 0;
  var n = e.length - 1;
  while (r <= n) {
    var a = Math.floor((r + n) / 2);
    var i = e[a];
    if (i < t) {
      r = a + 1;
    } else if (i > t) {
      n = a - 1;
    } else {
      r = a;
      n = a;
      break;
    }
  }
  return Math.max(Math.min(r, n, e.length - 1), 0);
};

var c = {};

Object.defineProperty(c, "__esModule", {
  value: !0
});

c.getStack = c.track = c.resetOffsetStack = c.offsetStack = c.setTracking = void 0;

var l = !0;

var u = 0;

c.setTracking = function setTracking(e) {
  l = e;
};

c.offsetStack = function offsetStack() {
  u++;
};

c.resetOffsetStack = function resetOffsetStack() {
  u--;
};

c.track = function track(e, t = []) {
  return [ new Proxy(e, {
    get(e, t, r) {
      if (l) {
        if ("push" === t) {
          return push;
        }
        if ("pop" === t) {
          return pop;
        }
        if ("shift" === t) {
          return shift;
        }
        if ("unshift" === t) {
          return unshift;
        }
        if ("splice" === t) {
          return splice;
        }
        if ("sort" === t) {
          return sort;
        }
        if ("reverse" === t) {
          return reverse;
        }
      }
      return Reflect.get(e, t, r);
    }
  }), t ];
  function push(...r) {
    t.push({
      stack: getStack(),
      length: r.length
    });
    return e.push(...r);
  }
  function pop() {
    if (t.length) {
      var r = t[t.length - 1];
      if (r.length > 1) {
        r.length--;
      } else {
        t.pop();
      }
    }
    return e.pop();
  }
  function shift() {
    if (t.length) {
      var r = t[0];
      if (r.length > 1) {
        r.length--;
      } else {
        t.shift();
      }
    }
    return e.shift();
  }
  function unshift(...r) {
    t.unshift({
      stack: getStack(),
      length: r.length
    });
    return e.unshift(...r);
  }
  function splice(r, n, ...a) {
    if (void 0 === n) {
      n = e.length - r;
    }
    var i = 0;
    var s;
    for (var f = 0; f < t.length; f++) {
      var o = t[f];
      var c = i;
      i = c + o.length;
      if (r >= c) {
        s = f + 1;
        var l = o.length;
        o.length = r - c;
        t.splice(s, 0, {
          stack: o.stack,
          length: l - o.length
        });
        break;
      }
    }
    if (void 0 === s) {
      throw new Error("Invalid splice operation");
    }
    var u = n;
    for (var v = s; v < t.length; v++) {
      var g = t[v];
      while (u > 0 && g.length > 0) {
        g.length--;
        u--;
      }
      if (0 === u) {
        break;
      }
    }
    t.splice(s, 0, {
      stack: getStack(),
      length: a.length
    });
    return e.splice(r, n, ...a);
  }
  function sort(r) {
    t.splice(0, t.length, {
      stack: getStack(),
      length: e.length
    });
    return e.sort(r);
  }
  function reverse() {
    t.splice(0, t.length, {
      stack: getStack(),
      length: e.length
    });
    return e.reverse();
  }
};

function getStack() {
  var e = (new Error).stack.split("\n")[3 + u].trim();
  if (e.endsWith(")")) {
    e = e.slice(e.lastIndexOf("(") + 1, -1);
  } else {
    e = e.slice(e.lastIndexOf(" ") + 1);
  }
  return e;
}

c.getStack = getStack;

var v = {};

Object.defineProperty(v, "__esModule", {
  value: !0
});

!function(e) {
  var t = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
    if (void 0 === n) {
      n = r;
    }
    var a = Object.getOwnPropertyDescriptor(t, r);
    if (!a || ("get" in a ? !t.__esModule : a.writable || a.configurable)) {
      a = {
        enumerable: !0,
        get: function() {
          return t[r];
        }
      };
    }
    Object.defineProperty(e, n, a);
  } : function(e, t, r, n) {
    if (void 0 === n) {
      n = r;
    }
    e[n] = t[r];
  });
  var r = this && this.__exportStar || function(e, r) {
    for (var n in e) {
      if ("default" !== n && !Object.prototype.hasOwnProperty.call(r, n)) {
        t(r, e, n);
      }
    }
  };
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  e.replaceRange = e.replaceSourceRange = e.replaceAll = e.replace = e.create = e.toString = e.getLength = void 0;
  var n = o;
  var a = c;
  r(v, e);
  r(c, e);
  function getLength(e) {
    var t = 0;
    for (var r of e) {
      t += "string" == typeof r ? r.length : r[0].length;
    }
    return t;
  }
  e.getLength = getLength;
  function toString(e) {
    return e.map((e => "string" == typeof e ? e : e[0])).join("");
  }
  e.toString = toString;
  e.create = function create(e) {
    return [ [ e, void 0, 0 ] ];
  };
  e.replace = function replace(e, t, ...r) {
    var n = toString(e).match(t);
    if (n && void 0 !== n.index) {
      var i = n.index;
      var s = i + n[0].length;
      (0, a.offsetStack)();
      replaceRange(e, i, s, ...r.map((e => "function" == typeof e ? e(n[0]) : e)));
      (0, a.resetOffsetStack)();
    }
  };
  e.replaceAll = function replaceAll(e, t, ...r) {
    var n = toString(e);
    var i = n.matchAll(t);
    var s = n.length;
    var f = 0;
    var _loop = function(t) {
      if (void 0 !== t.index) {
        var n = t.index + f;
        var i = n + t[0].length;
        (0, a.offsetStack)();
        replaceRange(e, n, i, ...r.map((e => "function" == typeof e ? e(t[0]) : e)));
        (0, a.resetOffsetStack)();
        var o = getLength(e);
        f += o - s;
        s = o;
      }
    };
    for (var o of i) {
      _loop(o);
    }
  };
  e.replaceSourceRange = function replaceSourceRange(e, t, r, n, ...i) {
    for (var s of e) {
      if ("string" == typeof s) {
        continue;
      }
      if (s[1] === t) {
        var f = s[2];
        var o = s[2] + s[0].length;
        if (f <= r && o >= n) {
          var c = [];
          if (r > f) {
            c.push(trimSegmentEnd(s, r - f));
          }
          for (var l of i) {
            c.push(l);
          }
          if (n < o) {
            c.push(trimSegmentStart(s, n - o));
          }
          combineStrings(c);
          (0, a.offsetStack)();
          e.splice(e.indexOf(s), 1, ...c);
          (0, a.resetOffsetStack)();
          return !0;
        }
      }
    }
    return !1;
  };
  function replaceRange(e, t, r, ...i) {
    var s = function toOffsets(e) {
      var t = [];
      var r = 0;
      for (var n of e) {
        t.push(r);
        r += "string" == typeof n ? n.length : n[0].length;
      }
      return t;
    }(e);
    var f = (0, n.binarySearch)(s, t);
    var o = (0, n.binarySearch)(s, r);
    var c = e[o];
    var l = s[f];
    var u = s[o];
    var v = s[o] + ("string" == typeof c ? c.length : c[0].length);
    var g = [];
    if (t > l) {
      g.push(trimSegmentEnd(e[f], t - l));
    }
    for (var d of i) {
      g.push(d);
    }
    if (r < v) {
      g.push(trimSegmentStart(c, r - u));
    }
    combineStrings(g);
    (0, a.offsetStack)();
    e.splice(f, o - f + 1, ...g);
    (0, a.resetOffsetStack)();
  }
  e.replaceRange = replaceRange;
  function combineStrings(e) {
    for (var t = e.length - 1; t >= 1; t--) {
      if ("string" == typeof e[t] && "string" == typeof e[t - 1]) {
        e[t - 1] = e[t - 1] + e[t];
        (0, a.offsetStack)();
        e.splice(t, 1);
        (0, a.resetOffsetStack)();
      }
    }
  }
  function trimSegmentEnd(e, t) {
    if ("string" == typeof e) {
      return e.slice(0, t);
    }
    return [ e[0].slice(0, t), ...e.slice(1) ];
  }
  function trimSegmentStart(e, t) {
    if ("string" == typeof e) {
      return e.slice(t);
    }
    if (t < 0) {
      t += e[0].length;
    }
    return [ e[0].slice(t), e[1], e[2] + t, ...e.slice(3) ];
  }
}(f);

var g = {};

var d = {};

Object.defineProperty(d, "__esModule", {
  value: !0
});

d.binarySearch = void 0;

d.binarySearch = function binarySearch(e, t) {
  var r = 0;
  var n = e.length - 1;
  var a;
  while (r <= n) {
    var i = Math.floor((r + n) / 2);
    var s = e[i];
    if (s < t) {
      r = i + 1;
    } else if (s > t) {
      n = i - 1;
    } else {
      r = i;
      n = i;
      a = i;
      break;
    }
  }
  return {
    low: Math.max(Math.min(r, n, e.length - 1), 0),
    high: Math.min(Math.max(r, n, 0), e.length - 1),
    match: a
  };
};

var h = {};

Object.defineProperty(h, "__esModule", {
  value: !0
});

h.translateOffset = void 0;

h.translateOffset = function translateOffset(e, t, r, n) {
  for (var a = 0; a < t.length; a++) {
    var i = t[a];
    if (e >= i && e <= i + n[a]) {
      return r[a] + e - i;
    }
  }
};

Object.defineProperty(g, "__esModule", {
  value: !0
});

g.SourceMap = void 0;

var p = d;

var S = h;

g.SourceMap = class SourceMap {
  constructor(e) {
    this.mappings = e;
  }
  getSourceOffset(e) {
    for (var t of this.findMatching(e, "generatedOffsets", "sourceOffsets")) {
      return t;
    }
  }
  getGeneratedOffset(e) {
    for (var t of this.findMatching(e, "sourceOffsets", "generatedOffsets")) {
      return t;
    }
  }
  getSourceOffsets(e) {
    return this.findMatching(e, "generatedOffsets", "sourceOffsets");
  }
  getGeneratedOffsets(e) {
    return this.findMatching(e, "sourceOffsets", "generatedOffsets");
  }
  * findMatching(e, t, r) {
    var n = this.getMemoBasedOnRange(t);
    if (0 === n.offsets.length) {
      return;
    }
    var {low: a, high: i} = (0, p.binarySearch)(n.offsets, e);
    var s = new Set;
    for (var f = a; f <= i; f++) {
      for (var o of n.mappings[f]) {
        if (s.has(o)) {
          continue;
        }
        s.add(o);
        var c = (0, S.translateOffset)(e, o[t], o[r], o.lengths);
        if (void 0 !== c) {
          yield [ c, o ];
        }
      }
    }
  }
  getMemoBasedOnRange(e) {
    return "sourceOffsets" === e ? this.sourceCodeOffsetsMemo ??= this.createMemo("sourceOffsets") : this.generatedCodeOffsetsMemo ??= this.createMemo("generatedOffsets");
  }
  createMemo(e) {
    var t = new Set;
    for (var r of this.mappings) {
      for (var n = 0; n < r[e].length; n++) {
        t.add(r[e][n]);
        t.add(r[e][n] + r.lengths[n]);
      }
    }
    var a = [ ...t ].sort(((e, t) => e - t));
    var i = a.map((() => new Set));
    for (var s of this.mappings) {
      for (var f = 0; f < s[e].length; f++) {
        var o = (0, p.binarySearch)(a, s[e][f]).match;
        var c = (0, p.binarySearch)(a, s[e][f] + s.lengths[f]).match;
        for (var l = o; l <= c; l++) {
          i[l].add(s);
        }
      }
    }
    return {
      offsets: a,
      mappings: i
    };
  }
};

var m = {};

Object.defineProperty(m, "__esModule", {
  value: !0
});

m.buildMappings = void 0;

m.buildMappings = function buildMappings(e) {
  var t = 0;
  var r = [];
  for (var n of e) {
    if ("string" == typeof n) {
      t += n.length;
    } else {
      r.push({
        source: n[1],
        sourceOffsets: [ n[2] ],
        generatedOffsets: [ t ],
        lengths: [ n[0].length ],
        data: n[3]
      });
      t += n[0].length;
    }
  }
  return r;
};

var k = {};

Object.defineProperty(k, "__esModule", {
  value: !0
});

k.buildStacks = void 0;

k.buildStacks = function buildStacks(e, t) {
  var r = 0;
  var n = 0;
  var a = [];
  for (var i of t) {
    var s = r;
    for (var f = 0; f < i.length; f++) {
      var o = e[n + f];
      if ("string" == typeof o) {
        r += o.length;
      } else {
        r += o[0].length;
      }
    }
    n += i.length;
    a.push({
      source: i.stack,
      range: [ s, r ]
    });
  }
  return a;
};

!function(e) {
  var t = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
    if (void 0 === n) {
      n = r;
    }
    var a = Object.getOwnPropertyDescriptor(t, r);
    if (!a || ("get" in a ? !t.__esModule : a.writable || a.configurable)) {
      a = {
        enumerable: !0,
        get: function() {
          return t[r];
        }
      };
    }
    Object.defineProperty(e, n, a);
  } : function(e, t, r, n) {
    if (void 0 === n) {
      n = r;
    }
    e[n] = t[r];
  });
  var r = this && this.__exportStar || function(e, r) {
    for (var n in e) {
      if ("default" !== n && !Object.prototype.hasOwnProperty.call(r, n)) {
        t(r, e, n);
      }
    }
  };
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  r(f, e);
  r(g, e);
  r(h, e);
  r(m, e);
  r(k, e);
}(s);

var y;

var O;

var getVirtualType = e => {
  if (e.endsWith(".vue")) {
    return "vue";
  } else if (e.endsWith(".svelte")) {
    return "svelte";
  }
};

var createVirtualCode = async (e, t, r) => {
  var n = getVirtualType(e);
  if ("vue" === n) {
    return (await (async () => O || (O = await import("./vue-chunk.mjs")))()).createVirtualCode(e, t, r);
  } else if ("svelte" === n) {
    return (await (async () => y || (y = await import("./svelte-chunk.mjs")))()).createVirtualCode(e, t, r);
  }
};

var loadVirtualCode = async (r, n, a) => {
  var i = await async function scanProjectFiles(r, n, a) {
    var i = new Set;
    var s = [ ...r ];
    var f = [];
    async function _scanVueFile(t, r) {
      var o = await e.stat(t);
      if (o.isSymbolicLink()) {
        if (!r) {
          await _scanVueFile(await e.realpath(t), t);
        }
      } else if (o.isFile()) {
        if (n(r || t)) {
          var c = await e.readFile(t, "utf8");
          f.push({
            fileId: t,
            snapshot: a.ScriptSnapshot.fromString(c)
          });
        }
      } else if (o.isDirectory() && !/\bnode_modules\b/.test(t)) {
        if (!i.has(t)) {
          s.push(t);
        }
      }
    }
    async function _scanVueFiles(r) {
      if (i.has(r)) {
        return;
      }
      i.add(r);
      var n;
      try {
        n = await e.readdir(r);
      } catch (e) {
        return;
      }
      for (var a of n) {
        var s = t.join(r, a);
        try {
          await _scanVueFile(s);
        } catch (e) {
          continue;
        }
      }
    }
    var o;
    while (null != (o = s.shift())) {
      await _scanVueFiles(o);
    }
    return f;
  }([ r, ...n.getRootDirectories().map((e => e.getPath())) ], (e => !!getVirtualType(e)), a);
  if (!i.length) {
    return;
  }
  var f = new Map;
  var o = new Map;
  var c = new Map;
  for (var l of i) {
    var u = a.createSourceFile(l.fileId, l.snapshot.getText(0, l.snapshot.getLength()), a.ScriptTarget.ESNext, !1, a.ScriptKind.External);
    var v = await createVirtualCode(l.fileId, l.snapshot, a);
    var g = v && v.snapshot;
    if (!v || !g) {
      continue;
    }
    var d = new s.SourceMap(v.mappings);
    var h = l.fileId + ".ts";
    var p = n.createSourceFile(h, g.getText(0, g.getLength()), {
      overwrite: !0,
      scriptKind: a.ScriptKind.TSX
    });
    if (p._markAsInProject) {
      p._markAsInProject();
    }
    f.set(l.fileId, p.compilerNode);
    o.set(h, u);
    c.set(l.fileId, d);
    c.set(h, d);
  }
  return (e, t) => {
    var r;
    var n;
    if ((r = f.get(e)) && (n = c.get(e))) {
      var a = null != t ? n.getGeneratedOffset(t) : null;
      return {
        fileId: r.fileName,
        file: r,
        position: a ? a[0] : t || 0,
        isVirtual: !0
      };
    } else if ((r = o.get(e)) && (n = c.get(e))) {
      var i = null != t ? n.getSourceOffset(t) : null;
      return {
        fileId: r.fileName,
        file: r,
        position: i ? i[0] : t || 0,
        isVirtual: !1
      };
    }
  };
};

var getFilePosition = (e, t, r, n) => {
  var a = {
    file: e.fileName,
    line: 1,
    col: 1,
    endLine: void 0,
    endColumn: void 0
  };
  var i = null != t && null != r ? t + r - 1 : void 0;
  if (n) {
    var s;
    if ((s = n(e.fileName, t)) && !s.isVirtual) {
      a.file = s.fileId;
      e = s.file;
      t = s.position;
      if (null != i && (s = n(e.fileName, i))) {
        i = s.position;
      }
    }
  }
  if (t) {
    var f = e.getLineAndCharacterOfPosition(t);
    a.line = f.line + 1;
    a.col = f.character + 1;
    if (null != i) {
      f = e.getLineAndCharacterOfPosition(i);
      a.endLine = f.line + 1;
      a.endColumn = f.character + 1;
    }
  }
  return a;
};

var w = n;

if (!r && !w) {
  throw new ReferenceError("Failed to receive parent message port");
}

var M = function(e) {
  e.Start = "START";
  e.Close = "CLOSE";
  e.Pull = "PULL";
  return e;
}(M || {});

var b = function(e) {
  e.Next = "NEXT";
  e.Throw = "THROW";
  e.Return = "RETURN";
  return e;
}(b || {});

var _ = {
  env: i,
  stderr: !1,
  stdout: !1,
  stdin: !1
};

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

function expose(e) {
  if (r) {
    var t = function captureStack() {
      var e = new Error;
      var t = Error.prepareStackTrace;
      try {
        var r;
        Error.prepareStackTrace = (e, t) => r = t;
        Error.captureStackTrace(e);
        if (!e.stack) {
          throw e;
        }
        return r && r.slice(2) || [];
      } finally {
        Error.prepareStackTrace = t;
      }
    }()[0];
    var n = t && t.getFileName();
    if (!n) {
      throw new ReferenceError("Captured stack trace is empty");
    }
    return function main(e) {
      var t;
      var r = 0;
      return (...n) => {
        if (!t) {
          (t = new a(e, _)).unref();
        }
        var i = 0 | ++r;
        var s = [];
        var f = !1;
        var o = !1;
        var c = !1;
        var l;
        var u;
        function cleanup() {
          o = !0;
          l = void 0;
          u = void 0;
          t.removeListener("message", receiveMessage);
          t.removeListener("error", receiveError);
        }
        function sendMessage(e) {
          t.postMessage({
            id: i,
            kind: e
          });
        }
        function receiveError(e) {
          cleanup();
          s.length = 1;
          s[0] = {
            id: i,
            kind: b.Throw,
            data: e
          };
        }
        function receiveMessage(e) {
          var t = e && "object" == typeof e && "kind" in e ? e : null;
          if (!t) {
            return;
          } else if (u && t.kind === b.Throw) {
            u(t.data);
            cleanup();
          } else if (l && t.kind === b.Return) {
            l({
              done: !0,
              value: t.data
            });
            cleanup();
          } else if (l && t.kind === b.Next) {
            c = !1;
            l({
              done: !1,
              value: t.data
            });
          } else if (t.kind === b.Throw || t.kind === b.Return) {
            s.push(t);
            cleanup();
          } else if (t.kind === b.Next) {
            s.push(t);
            c = !1;
          }
        }
        return {
          async next() {
            if (!f) {
              f = !0;
              t.addListener("message", receiveMessage);
              t.addListener("error", receiveError);
              t.postMessage({
                id: i,
                kind: M.Start,
                data: n
              });
            }
            if (o && !s.length) {
              return {
                done: !0
              };
            } else if (!o && !c && s.length <= 1) {
              c = !0;
              sendMessage(M.Pull);
            }
            var e = s.shift();
            if (e && e.kind === b.Throw) {
              cleanup();
              throw e.data;
            } else if (e && e.kind === b.Return) {
              cleanup();
              return {
                value: e.data,
                done: !0
              };
            } else if (e && e.kind === b.Next) {
              return {
                value: e.data,
                done: !1
              };
            } else {
              return new Promise(((e, t) => {
                l = t => {
                  l = void 0;
                  u = void 0;
                  e(t);
                };
                u = e => {
                  l = void 0;
                  u = void 0;
                  t(e);
                };
              }));
            }
          },
          async return() {
            if (!o) {
              cleanup();
              sendMessage(M.Close);
            }
            return {
              done: !0
            };
          },
          [asyncIteratorSymbol()]() {
            return this;
          }
        };
      };
    }(n.startsWith("file://") ? new URL(n) : n);
  } else {
    w.addListener("message", (t => {
      var r = t && "object" == typeof t && "kind" in t ? t : null;
      if (r) {
        !function thread(e, t) {
          if (e.kind !== M.Start) {
            return;
          }
          var r = e.id;
          var n = t(...e.data);
          var a = !1;
          var i = !1;
          var s = !1;
          function cleanup() {
            a = !0;
            w.removeListener("message", receiveMessage);
          }
          async function sendMessage(e, t) {
            try {
              w.postMessage({
                id: r,
                kind: e,
                data: t
              });
            } catch (e) {
              cleanup();
              if (n.throw) {
                var a = await n.throw();
                if (!1 === a.done && n.return) {
                  a = await n.return();
                  sendMessage(b.Return, a.value);
                } else {
                  sendMessage(b.Return, a.value);
                }
              } else {
                sendMessage(b.Return);
              }
            }
          }
          async function receiveMessage(e) {
            var t = e && "object" == typeof e && "kind" in e ? e : null;
            var r;
            if (!t) {
              return;
            } else if (t.kind === M.Close) {
              cleanup();
              if (n.return) {
                n.return();
              }
            } else if (t.kind === M.Pull && s) {
              i = !0;
            } else if (t.kind === M.Pull) {
              for (i = s = !0; i && !a; ) {
                try {
                  if ((r = await n.next()).done) {
                    cleanup();
                    if (n.return) {
                      r = await n.return();
                    }
                    sendMessage(b.Return, r.value);
                  } else {
                    i = !1;
                    sendMessage(b.Next, r.value);
                  }
                } catch (e) {
                  cleanup();
                  sendMessage(b.Throw, e);
                }
              }
              s = !1;
            }
          }
          w.addListener("message", receiveMessage);
        }(r, e);
      }
    }));
    return e;
  }
}

export { expose as e, getFilePosition as g, loadVirtualCode as l };
//# sourceMappingURL=index-chunk.mjs.map
