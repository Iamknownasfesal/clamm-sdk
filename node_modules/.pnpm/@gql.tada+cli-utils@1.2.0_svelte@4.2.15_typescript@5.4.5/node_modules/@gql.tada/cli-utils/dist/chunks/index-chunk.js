var e = require("node:fs/promises");

var r = require("node:path");

var t = require("node:worker_threads");

function _interopNamespaceDefault(e) {
  var r = Object.create(null);
  if (e) {
    Object.keys(e).forEach((function(t) {
      if ("default" !== t) {
        var n = Object.getOwnPropertyDescriptor(e, t);
        Object.defineProperty(r, t, n.get ? n : {
          enumerable: !0,
          get: function() {
            return e[t];
          }
        });
      }
    }));
  }
  r.default = e;
  return r;
}

var n = _interopNamespaceDefault(e);

var a = _interopNamespaceDefault(r);

var i = {};

var s = {};

var f = {};

Object.defineProperty(f, "__esModule", {
  value: !0
});

f.binarySearch = void 0;

f.binarySearch = function binarySearch$2(e, r) {
  var t = 0;
  var n = e.length - 1;
  while (t <= n) {
    var a = Math.floor((t + n) / 2);
    var i = e[a];
    if (i < r) {
      t = a + 1;
    } else if (i > r) {
      n = a - 1;
    } else {
      t = a;
      n = a;
      break;
    }
  }
  return Math.max(Math.min(t, n, e.length - 1), 0);
};

var o = {};

Object.defineProperty(o, "__esModule", {
  value: !0
});

o.getStack = o.track = o.resetOffsetStack = o.offsetStack = o.setTracking = void 0;

var c = !0;

var l = 0;

o.setTracking = function setTracking(e) {
  c = e;
};

o.offsetStack = function offsetStack() {
  l++;
};

o.resetOffsetStack = function resetOffsetStack() {
  l--;
};

o.track = function track(e, r = []) {
  return [ new Proxy(e, {
    get(e, r, t) {
      if (c) {
        if ("push" === r) {
          return push;
        }
        if ("pop" === r) {
          return pop;
        }
        if ("shift" === r) {
          return shift;
        }
        if ("unshift" === r) {
          return unshift;
        }
        if ("splice" === r) {
          return splice;
        }
        if ("sort" === r) {
          return sort;
        }
        if ("reverse" === r) {
          return reverse;
        }
      }
      return Reflect.get(e, r, t);
    }
  }), r ];
  function push(...t) {
    r.push({
      stack: getStack(),
      length: t.length
    });
    return e.push(...t);
  }
  function pop() {
    if (r.length) {
      var t = r[r.length - 1];
      if (t.length > 1) {
        t.length--;
      } else {
        r.pop();
      }
    }
    return e.pop();
  }
  function shift() {
    if (r.length) {
      var t = r[0];
      if (t.length > 1) {
        t.length--;
      } else {
        r.shift();
      }
    }
    return e.shift();
  }
  function unshift(...t) {
    r.unshift({
      stack: getStack(),
      length: t.length
    });
    return e.unshift(...t);
  }
  function splice(t, n, ...a) {
    if (void 0 === n) {
      n = e.length - t;
    }
    var i = 0;
    var s;
    for (var f = 0; f < r.length; f++) {
      var o = r[f];
      var c = i;
      i = c + o.length;
      if (t >= c) {
        s = f + 1;
        var l = o.length;
        o.length = t - c;
        r.splice(s, 0, {
          stack: o.stack,
          length: l - o.length
        });
        break;
      }
    }
    if (void 0 === s) {
      throw new Error("Invalid splice operation");
    }
    var u = n;
    for (var v = s; v < r.length; v++) {
      var g = r[v];
      while (u > 0 && g.length > 0) {
        g.length--;
        u--;
      }
      if (0 === u) {
        break;
      }
    }
    r.splice(s, 0, {
      stack: getStack(),
      length: a.length
    });
    return e.splice(t, n, ...a);
  }
  function sort(t) {
    r.splice(0, r.length, {
      stack: getStack(),
      length: e.length
    });
    return e.sort(t);
  }
  function reverse() {
    r.splice(0, r.length, {
      stack: getStack(),
      length: e.length
    });
    return e.reverse();
  }
};

function getStack() {
  var e = (new Error).stack.split("\n")[3 + l].trim();
  if (e.endsWith(")")) {
    e = e.slice(e.lastIndexOf("(") + 1, -1);
  } else {
    e = e.slice(e.lastIndexOf(" ") + 1);
  }
  return e;
}

o.getStack = getStack;

var u = {};

Object.defineProperty(u, "__esModule", {
  value: !0
});

!function(e) {
  var r = this && this.__createBinding || (Object.create ? function(e, r, t, n) {
    if (void 0 === n) {
      n = t;
    }
    var a = Object.getOwnPropertyDescriptor(r, t);
    if (!a || ("get" in a ? !r.__esModule : a.writable || a.configurable)) {
      a = {
        enumerable: !0,
        get: function() {
          return r[t];
        }
      };
    }
    Object.defineProperty(e, n, a);
  } : function(e, r, t, n) {
    if (void 0 === n) {
      n = t;
    }
    e[n] = r[t];
  });
  var t = this && this.__exportStar || function(e, t) {
    for (var n in e) {
      if ("default" !== n && !Object.prototype.hasOwnProperty.call(t, n)) {
        r(t, e, n);
      }
    }
  };
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  e.replaceRange = e.replaceSourceRange = e.replaceAll = e.replace = e.create = e.toString = e.getLength = void 0;
  var n = f;
  var a = o;
  t(u, e);
  t(o, e);
  function getLength(e) {
    var r = 0;
    for (var t of e) {
      r += "string" == typeof t ? t.length : t[0].length;
    }
    return r;
  }
  e.getLength = getLength;
  function toString(e) {
    return e.map((e => "string" == typeof e ? e : e[0])).join("");
  }
  e.toString = toString;
  e.create = function create(e) {
    return [ [ e, void 0, 0 ] ];
  };
  e.replace = function replace(e, r, ...t) {
    var n = toString(e).match(r);
    if (n && void 0 !== n.index) {
      var i = n.index;
      var s = i + n[0].length;
      (0, a.offsetStack)();
      replaceRange(e, i, s, ...t.map((e => "function" == typeof e ? e(n[0]) : e)));
      (0, a.resetOffsetStack)();
    }
  };
  e.replaceAll = function replaceAll(e, r, ...t) {
    var n = toString(e);
    var i = n.matchAll(r);
    var s = n.length;
    var f = 0;
    var _loop = function(r) {
      if (void 0 !== r.index) {
        var n = r.index + f;
        var i = n + r[0].length;
        (0, a.offsetStack)();
        replaceRange(e, n, i, ...t.map((e => "function" == typeof e ? e(r[0]) : e)));
        (0, a.resetOffsetStack)();
        var o = getLength(e);
        f += o - s;
        s = o;
      }
    };
    for (var o of i) {
      _loop(o);
    }
  };
  e.replaceSourceRange = function replaceSourceRange(e, r, t, n, ...i) {
    for (var s of e) {
      if ("string" == typeof s) {
        continue;
      }
      if (s[1] === r) {
        var f = s[2];
        var o = s[2] + s[0].length;
        if (f <= t && o >= n) {
          var c = [];
          if (t > f) {
            c.push(trimSegmentEnd(s, t - f));
          }
          for (var l of i) {
            c.push(l);
          }
          if (n < o) {
            c.push(trimSegmentStart(s, n - o));
          }
          combineStrings(c);
          (0, a.offsetStack)();
          e.splice(e.indexOf(s), 1, ...c);
          (0, a.resetOffsetStack)();
          return !0;
        }
      }
    }
    return !1;
  };
  function replaceRange(e, r, t, ...i) {
    var s = function toOffsets(e) {
      var r = [];
      var t = 0;
      for (var n of e) {
        r.push(t);
        t += "string" == typeof n ? n.length : n[0].length;
      }
      return r;
    }(e);
    var f = (0, n.binarySearch)(s, r);
    var o = (0, n.binarySearch)(s, t);
    var c = e[o];
    var l = s[f];
    var u = s[o];
    var v = s[o] + ("string" == typeof c ? c.length : c[0].length);
    var g = [];
    if (r > l) {
      g.push(trimSegmentEnd(e[f], r - l));
    }
    for (var d of i) {
      g.push(d);
    }
    if (t < v) {
      g.push(trimSegmentStart(c, t - u));
    }
    combineStrings(g);
    (0, a.offsetStack)();
    e.splice(f, o - f + 1, ...g);
    (0, a.resetOffsetStack)();
  }
  e.replaceRange = replaceRange;
  function combineStrings(e) {
    for (var r = e.length - 1; r >= 1; r--) {
      if ("string" == typeof e[r] && "string" == typeof e[r - 1]) {
        e[r - 1] = e[r - 1] + e[r];
        (0, a.offsetStack)();
        e.splice(r, 1);
        (0, a.resetOffsetStack)();
      }
    }
  }
  function trimSegmentEnd(e, r) {
    if ("string" == typeof e) {
      return e.slice(0, r);
    }
    return [ e[0].slice(0, r), ...e.slice(1) ];
  }
  function trimSegmentStart(e, r) {
    if ("string" == typeof e) {
      return e.slice(r);
    }
    if (r < 0) {
      r += e[0].length;
    }
    return [ e[0].slice(r), e[1], e[2] + r, ...e.slice(3) ];
  }
}(s);

var v = {};

var g = {};

Object.defineProperty(g, "__esModule", {
  value: !0
});

g.binarySearch = void 0;

g.binarySearch = function binarySearch(e, r) {
  var t = 0;
  var n = e.length - 1;
  var a;
  while (t <= n) {
    var i = Math.floor((t + n) / 2);
    var s = e[i];
    if (s < r) {
      t = i + 1;
    } else if (s > r) {
      n = i - 1;
    } else {
      t = i;
      n = i;
      a = i;
      break;
    }
  }
  return {
    low: Math.max(Math.min(t, n, e.length - 1), 0),
    high: Math.min(Math.max(t, n, 0), e.length - 1),
    match: a
  };
};

var d = {};

Object.defineProperty(d, "__esModule", {
  value: !0
});

d.translateOffset = void 0;

d.translateOffset = function translateOffset(e, r, t, n) {
  for (var a = 0; a < r.length; a++) {
    var i = r[a];
    if (e >= i && e <= i + n[a]) {
      return t[a] + e - i;
    }
  }
};

Object.defineProperty(v, "__esModule", {
  value: !0
});

v.SourceMap = void 0;

var h = g;

var p = d;

v.SourceMap = class SourceMap {
  constructor(e) {
    this.mappings = e;
  }
  getSourceOffset(e) {
    for (var r of this.findMatching(e, "generatedOffsets", "sourceOffsets")) {
      return r;
    }
  }
  getGeneratedOffset(e) {
    for (var r of this.findMatching(e, "sourceOffsets", "generatedOffsets")) {
      return r;
    }
  }
  getSourceOffsets(e) {
    return this.findMatching(e, "generatedOffsets", "sourceOffsets");
  }
  getGeneratedOffsets(e) {
    return this.findMatching(e, "sourceOffsets", "generatedOffsets");
  }
  * findMatching(e, r, t) {
    var n = this.getMemoBasedOnRange(r);
    if (0 === n.offsets.length) {
      return;
    }
    var {low: a, high: i} = (0, h.binarySearch)(n.offsets, e);
    var s = new Set;
    for (var f = a; f <= i; f++) {
      for (var o of n.mappings[f]) {
        if (s.has(o)) {
          continue;
        }
        s.add(o);
        var c = (0, p.translateOffset)(e, o[r], o[t], o.lengths);
        if (void 0 !== c) {
          yield [ c, o ];
        }
      }
    }
  }
  getMemoBasedOnRange(e) {
    return "sourceOffsets" === e ? this.sourceCodeOffsetsMemo ??= this.createMemo("sourceOffsets") : this.generatedCodeOffsetsMemo ??= this.createMemo("generatedOffsets");
  }
  createMemo(e) {
    var r = new Set;
    for (var t of this.mappings) {
      for (var n = 0; n < t[e].length; n++) {
        r.add(t[e][n]);
        r.add(t[e][n] + t.lengths[n]);
      }
    }
    var a = [ ...r ].sort(((e, r) => e - r));
    var i = a.map((() => new Set));
    for (var s of this.mappings) {
      for (var f = 0; f < s[e].length; f++) {
        var o = (0, h.binarySearch)(a, s[e][f]).match;
        var c = (0, h.binarySearch)(a, s[e][f] + s.lengths[f]).match;
        for (var l = o; l <= c; l++) {
          i[l].add(s);
        }
      }
    }
    return {
      offsets: a,
      mappings: i
    };
  }
};

var S = {};

Object.defineProperty(S, "__esModule", {
  value: !0
});

S.buildMappings = void 0;

S.buildMappings = function buildMappings(e) {
  var r = 0;
  var t = [];
  for (var n of e) {
    if ("string" == typeof n) {
      r += n.length;
    } else {
      t.push({
        source: n[1],
        sourceOffsets: [ n[2] ],
        generatedOffsets: [ r ],
        lengths: [ n[0].length ],
        data: n[3]
      });
      r += n[0].length;
    }
  }
  return t;
};

var k = {};

Object.defineProperty(k, "__esModule", {
  value: !0
});

k.buildStacks = void 0;

k.buildStacks = function buildStacks(e, r) {
  var t = 0;
  var n = 0;
  var a = [];
  for (var i of r) {
    var s = t;
    for (var f = 0; f < i.length; f++) {
      var o = e[n + f];
      if ("string" == typeof o) {
        t += o.length;
      } else {
        t += o[0].length;
      }
    }
    n += i.length;
    a.push({
      source: i.stack,
      range: [ s, t ]
    });
  }
  return a;
};

!function(e) {
  var r = this && this.__createBinding || (Object.create ? function(e, r, t, n) {
    if (void 0 === n) {
      n = t;
    }
    var a = Object.getOwnPropertyDescriptor(r, t);
    if (!a || ("get" in a ? !r.__esModule : a.writable || a.configurable)) {
      a = {
        enumerable: !0,
        get: function() {
          return r[t];
        }
      };
    }
    Object.defineProperty(e, n, a);
  } : function(e, r, t, n) {
    if (void 0 === n) {
      n = t;
    }
    e[n] = r[t];
  });
  var t = this && this.__exportStar || function(e, t) {
    for (var n in e) {
      if ("default" !== n && !Object.prototype.hasOwnProperty.call(t, n)) {
        r(t, e, n);
      }
    }
  };
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  t(s, e);
  t(v, e);
  t(d, e);
  t(S, e);
  t(k, e);
}(i);

var m;

var y;

var getVirtualType = e => {
  if (e.endsWith(".vue")) {
    return "vue";
  } else if (e.endsWith(".svelte")) {
    return "svelte";
  }
};

var createVirtualCode = async (e, r, t) => {
  var n = getVirtualType(e);
  if ("vue" === n) {
    return (await (async () => y || (y = await Promise.resolve().then((function() {
      return require("./vue-chunk.js");
    }))))()).createVirtualCode(e, r, t);
  } else if ("svelte" === n) {
    return (await (async () => m || (m = await Promise.resolve().then((function() {
      return require("./svelte-chunk.js");
    }))))()).createVirtualCode(e, r, t);
  }
};

var O = t.parentPort;

if (!t.isMainThread && !O) {
  throw new ReferenceError("Failed to receive parent message port");
}

var M = function(e) {
  e.Start = "START";
  e.Close = "CLOSE";
  e.Pull = "PULL";
  return e;
}(M || {});

var w = function(e) {
  e.Next = "NEXT";
  e.Throw = "THROW";
  e.Return = "RETURN";
  return e;
}(w || {});

var b = {
  env: t.SHARE_ENV,
  stderr: !1,
  stdout: !1,
  stdin: !1
};

var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";

exports.expose = function expose(e) {
  if (t.isMainThread) {
    var r = function captureStack() {
      var e = new Error;
      var r = Error.prepareStackTrace;
      try {
        var t;
        Error.prepareStackTrace = (e, r) => t = r;
        Error.captureStackTrace(e);
        if (!e.stack) {
          throw e;
        }
        return t && t.slice(2) || [];
      } finally {
        Error.prepareStackTrace = r;
      }
    }()[0];
    var n = r && r.getFileName();
    if (!n) {
      throw new ReferenceError("Captured stack trace is empty");
    }
    return function main(e) {
      var r;
      var n = 0;
      return (...a) => {
        if (!r) {
          (r = new t.Worker(e, b)).unref();
        }
        var i = 0 | ++n;
        var s = [];
        var f = !1;
        var o = !1;
        var c = !1;
        var l;
        var u;
        function cleanup() {
          o = !0;
          l = void 0;
          u = void 0;
          r.removeListener("message", receiveMessage);
          r.removeListener("error", receiveError);
        }
        function sendMessage(e) {
          r.postMessage({
            id: i,
            kind: e
          });
        }
        function receiveError(e) {
          cleanup();
          s.length = 1;
          s[0] = {
            id: i,
            kind: w.Throw,
            data: e
          };
        }
        function receiveMessage(e) {
          var r = e && "object" == typeof e && "kind" in e ? e : null;
          if (!r) {
            return;
          } else if (u && r.kind === w.Throw) {
            u(r.data);
            cleanup();
          } else if (l && r.kind === w.Return) {
            l({
              done: !0,
              value: r.data
            });
            cleanup();
          } else if (l && r.kind === w.Next) {
            c = !1;
            l({
              done: !1,
              value: r.data
            });
          } else if (r.kind === w.Throw || r.kind === w.Return) {
            s.push(r);
            cleanup();
          } else if (r.kind === w.Next) {
            s.push(r);
            c = !1;
          }
        }
        return {
          async next() {
            if (!f) {
              f = !0;
              r.addListener("message", receiveMessage);
              r.addListener("error", receiveError);
              r.postMessage({
                id: i,
                kind: M.Start,
                data: a
              });
            }
            if (o && !s.length) {
              return {
                done: !0
              };
            } else if (!o && !c && s.length <= 1) {
              c = !0;
              sendMessage(M.Pull);
            }
            var e = s.shift();
            if (e && e.kind === w.Throw) {
              cleanup();
              throw e.data;
            } else if (e && e.kind === w.Return) {
              cleanup();
              return {
                value: e.data,
                done: !0
              };
            } else if (e && e.kind === w.Next) {
              return {
                value: e.data,
                done: !1
              };
            } else {
              return new Promise(((e, r) => {
                l = r => {
                  l = void 0;
                  u = void 0;
                  e(r);
                };
                u = e => {
                  l = void 0;
                  u = void 0;
                  r(e);
                };
              }));
            }
          },
          async return() {
            if (!o) {
              cleanup();
              sendMessage(M.Close);
            }
            return {
              done: !0
            };
          },
          [asyncIteratorSymbol()]() {
            return this;
          }
        };
      };
    }(n.startsWith("file://") ? new URL(n) : n);
  } else {
    O.addListener("message", (r => {
      var t = r && "object" == typeof r && "kind" in r ? r : null;
      if (t) {
        !function thread(e, r) {
          if (e.kind !== M.Start) {
            return;
          }
          var t = e.id;
          var n = r(...e.data);
          var a = !1;
          var i = !1;
          var s = !1;
          function cleanup() {
            a = !0;
            O.removeListener("message", receiveMessage);
          }
          async function sendMessage(e, r) {
            try {
              O.postMessage({
                id: t,
                kind: e,
                data: r
              });
            } catch (e) {
              cleanup();
              if (n.throw) {
                var a = await n.throw();
                if (!1 === a.done && n.return) {
                  a = await n.return();
                  sendMessage(w.Return, a.value);
                } else {
                  sendMessage(w.Return, a.value);
                }
              } else {
                sendMessage(w.Return);
              }
            }
          }
          async function receiveMessage(e) {
            var r = e && "object" == typeof e && "kind" in e ? e : null;
            var t;
            if (!r) {
              return;
            } else if (r.kind === M.Close) {
              cleanup();
              if (n.return) {
                n.return();
              }
            } else if (r.kind === M.Pull && s) {
              i = !0;
            } else if (r.kind === M.Pull) {
              for (i = s = !0; i && !a; ) {
                try {
                  if ((t = await n.next()).done) {
                    cleanup();
                    if (n.return) {
                      t = await n.return();
                    }
                    sendMessage(w.Return, t.value);
                  } else {
                    i = !1;
                    sendMessage(w.Next, t.value);
                  }
                } catch (e) {
                  cleanup();
                  sendMessage(w.Throw, e);
                }
              }
              s = !1;
            }
          }
          O.addListener("message", receiveMessage);
        }(t, e);
      }
    }));
    return e;
  }
};

exports.getFilePosition = (e, r, t, n) => {
  var a = {
    file: e.fileName,
    line: 1,
    col: 1,
    endLine: void 0,
    endColumn: void 0
  };
  var i = null != r && null != t ? r + t - 1 : void 0;
  if (n) {
    var s;
    if ((s = n(e.fileName, r)) && !s.isVirtual) {
      a.file = s.fileId;
      e = s.file;
      r = s.position;
      if (null != i && (s = n(e.fileName, i))) {
        i = s.position;
      }
    }
  }
  if (r) {
    var f = e.getLineAndCharacterOfPosition(r);
    a.line = f.line + 1;
    a.col = f.character + 1;
    if (null != i) {
      f = e.getLineAndCharacterOfPosition(i);
      a.endLine = f.line + 1;
      a.endColumn = f.character + 1;
    }
  }
  return a;
};

exports.loadVirtualCode = async (e, r, t) => {
  var s = await async function scanProjectFiles(e, r, t) {
    var i = new Set;
    var s = [ ...e ];
    var f = [];
    async function _scanVueFile(e, a) {
      var o = await n.stat(e);
      if (o.isSymbolicLink()) {
        if (!a) {
          await _scanVueFile(await n.realpath(e), e);
        }
      } else if (o.isFile()) {
        if (r(a || e)) {
          var c = await n.readFile(e, "utf8");
          f.push({
            fileId: e,
            snapshot: t.ScriptSnapshot.fromString(c)
          });
        }
      } else if (o.isDirectory() && !/\bnode_modules\b/.test(e)) {
        if (!i.has(e)) {
          s.push(e);
        }
      }
    }
    async function _scanVueFiles(e) {
      if (i.has(e)) {
        return;
      }
      i.add(e);
      var r;
      try {
        r = await n.readdir(e);
      } catch (e) {
        return;
      }
      for (var t of r) {
        var s = a.join(e, t);
        try {
          await _scanVueFile(s);
        } catch (e) {
          continue;
        }
      }
    }
    var o;
    while (null != (o = s.shift())) {
      await _scanVueFiles(o);
    }
    return f;
  }([ e, ...r.getRootDirectories().map((e => e.getPath())) ], (e => !!getVirtualType(e)), t);
  if (!s.length) {
    return;
  }
  var f = new Map;
  var o = new Map;
  var c = new Map;
  for (var l of s) {
    var u = t.createSourceFile(l.fileId, l.snapshot.getText(0, l.snapshot.getLength()), t.ScriptTarget.ESNext, !1, t.ScriptKind.External);
    var v = await createVirtualCode(l.fileId, l.snapshot, t);
    var g = v && v.snapshot;
    if (!v || !g) {
      continue;
    }
    var d = new i.SourceMap(v.mappings);
    var h = l.fileId + ".ts";
    var p = r.createSourceFile(h, g.getText(0, g.getLength()), {
      overwrite: !0,
      scriptKind: t.ScriptKind.TSX
    });
    if (p._markAsInProject) {
      p._markAsInProject();
    }
    f.set(l.fileId, p.compilerNode);
    o.set(h, u);
    c.set(l.fileId, d);
    c.set(h, d);
  }
  return (e, r) => {
    var t;
    var n;
    if ((t = f.get(e)) && (n = c.get(e))) {
      var a = null != r ? n.getGeneratedOffset(r) : null;
      return {
        fileId: t.fileName,
        file: t,
        position: a ? a[0] : r || 0,
        isVirtual: !0
      };
    } else if ((t = o.get(e)) && (n = c.get(e))) {
      var i = null != r ? n.getSourceOffset(r) : null;
      return {
        fileId: t.fileName,
        file: t,
        position: i ? i[0] : r || 0,
        isVirtual: !1
      };
    }
  };
};
//# sourceMappingURL=index-chunk.js.map
