{"version":3,"file":"thread-chunk2.js","sources":["../../src/commands/turbo/thread.ts"],"sourcesContent":["import * as path from 'node:path';\nimport { Project, TypeFormatFlags, TypeFlags, ScriptKind, ts } from 'ts-morph';\n\nimport type { GraphQLSPConfig } from '@gql.tada/internal';\nimport { init } from '@0no-co/graphqlsp/api';\n\nimport { getFilePosition, loadVirtualCode } from '../../ts';\nimport { expose } from '../../threads';\n\nimport type { TurboSignal, TurboWarning } from './types';\n\nexport interface TurboParams {\n  rootPath: string;\n  configPath: string;\n  pluginConfig: GraphQLSPConfig;\n}\n\nasync function* _runTurbo(params: TurboParams): AsyncIterableIterator<TurboSignal> {\n  init({ typescript: ts });\n\n  const projectPath = path.dirname(params.configPath);\n  const project = new Project({\n    tsConfigFilePath: params.configPath,\n    skipAddingFilesFromTsConfig: true,\n  });\n\n  // NOTE: We add our override declaration here before loading all files\n  // This sets `__cacheDisabled` on the turbo cache, which disables the cache temporarily\n  // If we don't disable the cache then we couldn't regenerate it from inferred types\n  const overrideFile = project.createSourceFile(\n    '__gql-tada-override__.d.ts',\n    DECLARATION_OVERRIDE,\n    {\n      overwrite: true,\n      scriptKind: ScriptKind.TS,\n    }\n  );\n  if (overrideFile._markAsInProject) overrideFile._markAsInProject();\n\n  project.addSourceFilesFromTsConfig(params.configPath);\n\n  const getVirtualPosition = await loadVirtualCode(projectPath, project, ts);\n  if (!!getVirtualPosition) {\n    yield { kind: 'EXTERNAL_WARNING' };\n  }\n\n  // Filter source files by whether they're under the relevant root path\n  const sourceFiles = project.getSourceFiles().filter((sourceFile) => {\n    const filePath = path.resolve(projectPath, sourceFile.getFilePath());\n    const relative = path.relative(params.rootPath, filePath);\n    return !relative.startsWith('..');\n  });\n\n  yield {\n    kind: 'FILE_COUNT',\n    fileCount: sourceFiles.length,\n  };\n\n  const checker = project.getTypeChecker().compilerObject;\n  for (const { compilerNode: sourceFile } of sourceFiles) {\n    let filePath = sourceFile.fileName;\n    const cache: Record<string, string> = {};\n    const warnings: TurboWarning[] = [];\n\n    const calls = findAllCallExpressions(sourceFile, params.pluginConfig);\n    for (const call of calls) {\n      const returnType = checker.getTypeAtLocation(call);\n      const argumentType = checker.getTypeAtLocation(call.arguments[0]);\n      // NOTE: `returnType.symbol` is incorrectly typed and is in fact\n      // optional and not always present\n      if (!returnType.symbol || returnType.symbol.getEscapedName() !== 'TadaDocumentNode') {\n        const position = getFilePosition(\n          sourceFile,\n          call.getStart(),\n          undefined,\n          getVirtualPosition\n        );\n        filePath = position.file;\n        warnings.push({\n          message:\n            `The discovered document is not of type \"TadaDocumentNode\".\\n` +\n            'If this is unexpected, please file an issue describing your case.',\n          file: position.file,\n          line: position.line,\n          col: position.col,\n        });\n        continue;\n      }\n\n      const key: string =\n        'value' in argumentType &&\n        typeof argumentType.value === 'string' &&\n        (argumentType.flags & TypeFlags.StringLiteral) === 0\n          ? JSON.stringify(argumentType.value)\n          : checker.typeToString(argumentType, call, BUILDER_FLAGS);\n      cache[key] = checker.typeToString(returnType, call, BUILDER_FLAGS);\n    }\n\n    yield {\n      kind: 'FILE_TURBO',\n      filePath,\n      cache,\n      warnings,\n    };\n  }\n}\n\nexport const runTurbo = expose(_runTurbo);\n\nconst BUILDER_FLAGS: TypeFormatFlags =\n  TypeFormatFlags.NoTruncation |\n  TypeFormatFlags.NoTypeReduction |\n  TypeFormatFlags.InTypeAlias |\n  TypeFormatFlags.UseFullyQualifiedType |\n  TypeFormatFlags.GenerateNamesForShadowedTypeParams |\n  TypeFormatFlags.UseAliasDefinedOutsideCurrentScope |\n  TypeFormatFlags.AllowUniqueESSymbolType |\n  TypeFormatFlags.WriteTypeArgumentsOfSignature;\n\nconst DECLARATION_OVERRIDE = `\nimport * as _gqlTada from 'gql.tada';\ndeclare module 'gql.tada' {\n  interface setupCache {\n    readonly __cacheDisabled: true;\n  }\n}\n`.trim();\n\nfunction findAllCallExpressions(\n  sourceFile: ts.SourceFile,\n  config: GraphQLSPConfig\n): Array<ts.CallExpression> {\n  const result: ts.CallExpression[] = [];\n  const templates = new Set([config.template, 'graphql', 'gql'].filter(Boolean));\n  function find(node: ts.Node) {\n    if (ts.isCallExpression(node) && templates.has(node.expression.getText())) {\n      result.push(node);\n      return;\n    } else {\n      ts.forEachChild(node, find);\n    }\n  }\n  find(sourceFile);\n  return result;\n}\n"],"names":["runTurbo","expose","async","_runTurbo","params","init","typescript","ts","projectPath","path","dirname","configPath","project","Project","tsConfigFilePath","skipAddingFilesFromTsConfig","overrideFile","createSourceFile","DECLARATION_OVERRIDE","overwrite","scriptKind","ScriptKind","TS","_markAsInProject","addSourceFilesFromTsConfig","getVirtualPosition","loadVirtualCode","kind","sourceFiles","getSourceFiles","filter","sourceFile","filePath","resolve","getFilePath","relative","rootPath","startsWith","fileCount","length","checker","getTypeChecker","compilerObject","compilerNode","fileName","cache","warnings","calls","findAllCallExpressions","pluginConfig","call","returnType","getTypeAtLocation","argumentType","arguments","symbol","getEscapedName","position","getFilePosition","getStart","undefined","file","push","message","line","col","value","flags","TypeFlags","StringLiteral","JSON","stringify","typeToString","BUILDER_FLAGS","TypeFormatFlags","NoTruncation","NoTypeReduction","InTypeAlias","UseFullyQualifiedType","GenerateNamesForShadowedTypeParams","UseAliasDefinedOutsideCurrentScope","AllowUniqueESSymbolType","WriteTypeArgumentsOfSignature","trim","config","result","templates","Set","template","Boolean","find","node","isCallExpression","has","expression","getText","forEachChild"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA2GaA,IAAWC,EAAMA,QA1F9BC,gBAAgBC,UAAUC;EACxBC,OAAK;IAAEC,YAAYC,EAAAA;;EAEnB,IAAMC,IAAcC,EAAKC,QAAQN,EAAOO;EACxC,IAAMC,IAAU,IAAIC,UAAQ;IAC1BC,kBAAkBV,EAAOO;IACzBI,8BAA6B;;EAM/B,IAAMC,IAAeJ,EAAQK,iBAC3B,8BACAC,GACA;IACEC,YAAW;IACXC,YAAYC,EAAUA,WAACC;;EAG3B,IAAIN,EAAaO;IAAkBP,EAAaO;;EAEhDX,EAAQY,2BAA2BpB,EAAOO;EAE1C,IAAMc,UAA2BC,EAAeA,gBAAClB,GAAaI,GAASL,EAAEA;EACzE,IAAMkB;UACE;MAAEE,MAAM;;;EAIhB,IAAMC,IAAchB,EAAQiB,iBAAiBC,QAAQC;IACnD,IAAMC,IAAWvB,EAAKwB,QAAQzB,GAAauB,EAAWG;IAEtD,QADiBzB,EAAK0B,SAAS/B,EAAOgC,UAAUJ,GAC/BK,WAAW;AAAK;QAG7B;IACJV,MAAM;IACNW,WAAWV,EAAYW;;EAGzB,IAAMC,IAAU5B,EAAQ6B,iBAAiBC;EACzC,KAAK,KAAQC,cAAcZ,MAAgBH,GAAa;IACtD,IAAII,IAAWD,EAAWa;IAC1B,IAAMC,IAAgC,CAAA;IACtC,IAAMC,IAA2B;IAEjC,IAAMC,IAAQC,uBAAuBjB,GAAY3B,EAAO6C;IACxD,KAAK,IAAMC,KAAQH,GAAO;MACxB,IAAMI,IAAaX,EAAQY,kBAAkBF;MAC7C,IAAMG,IAAeb,EAAQY,kBAAkBF,EAAKI,UAAU;MAG9D,KAAKH,EAAWI,UAAiD,uBAAvCJ,EAAWI,OAAOC,kBAAyC;QACnF,IAAMC,IAAWC,EAAeA,gBAC9B3B,GACAmB,EAAKS,iBACLC,GACAnC;QAEFO,IAAWyB,EAASI;QACpBf,EAASgB,KAAK;UACZC,SACG;UAEHF,MAAMJ,EAASI;UACfG,MAAMP,EAASO;UACfC,KAAKR,EAASQ;;QAEhB;AACF;MAQApB,EALE,WAAWQ,KACmB,mBAAvBA,EAAaa,SAC+B,MAAlDb,EAAac,QAAQC,YAAUC,iBAC5BC,KAAKC,UAAUlB,EAAaa,SAC5B1B,EAAQgC,aAAanB,GAAcH,GAAMuB,MAClCjC,EAAQgC,aAAarB,GAAYD,GAAMuB;AACtD;UAEM;MACJ9C,MAAM;MACNK;MACAa;MACAC;;AAEJ;AACF;;AAIA,IAAM2B,IACJC,EAAeA,gBAACC,eAChBD,EAAAA,gBAAgBE,kBAChBF,EAAAA,gBAAgBG,cAChBH,EAAeA,gBAACI,wBAChBJ,EAAeA,gBAACK,qCAChBL,kBAAgBM,qCAChBN,EAAAA,gBAAgBO,0BAChBP,EAAeA,gBAACQ;;AAElB,IAAMhE,IAAwB,gJAO5BiE;;AAEF,SAASnC,uBACPjB,GACAqD;EAEA,IAAMC,IAA8B;EACpC,IAAMC,IAAY,IAAIC,IAAI,EAACH,EAAOI,UAAU,WAAW,QAAO1D,OAAO2D;GACrE,SAASC,KAAKC;IACZ,IAAIpF,EAAEA,GAACqF,iBAAiBD,MAASL,EAAUO,IAAIF,EAAKG,WAAWC,YAAY;MACzEV,EAAOvB,KAAK6B;MACZ;AACF;MACEpF,EAAAA,GAAGyF,aAAaL,GAAMD;;AAE1B,GACAA,CAAK3D;EACL,OAAOsD;AACT;;"}