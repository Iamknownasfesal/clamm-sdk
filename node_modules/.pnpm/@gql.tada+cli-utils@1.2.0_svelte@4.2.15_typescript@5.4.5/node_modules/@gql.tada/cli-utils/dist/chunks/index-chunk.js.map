{"version":3,"file":"index-chunk.js","sources":["../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/binarySearch.js","../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/track.js","../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/types.js","../../../../node_modules/.pnpm/muggle-string@0.4.1/node_modules/muggle-string/out/index.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/binarySearch.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/translateOffset.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/sourceMap.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/buildMappings.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/lib/buildStacks.js","../../../../node_modules/.pnpm/@volar+source-map@2.1.6/node_modules/@volar/source-map/index.js","../../src/ts/virtualCode/index.ts","../../src/threads/index.ts","../../src/ts/utils.ts","../../src/ts/virtualCode/scan.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binarySearch = void 0;\nfunction binarySearch(offsets, start) {\n    let low = 0;\n    let high = offsets.length - 1;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const midValue = offsets[mid];\n        if (midValue < start) {\n            low = mid + 1;\n        }\n        else if (midValue > start) {\n            high = mid - 1;\n        }\n        else {\n            low = mid;\n            high = mid;\n            break;\n        }\n    }\n    return Math.max(Math.min(low, high, offsets.length - 1), 0);\n}\nexports.binarySearch = binarySearch;\n//# sourceMappingURL=binarySearch.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getStack = exports.track = exports.resetOffsetStack = exports.offsetStack = exports.setTracking = void 0;\nlet tracking = true;\nlet stackOffset = 0;\nfunction setTracking(value) {\n    tracking = value;\n}\nexports.setTracking = setTracking;\nfunction offsetStack() {\n    stackOffset++;\n}\nexports.offsetStack = offsetStack;\nfunction resetOffsetStack() {\n    stackOffset--;\n}\nexports.resetOffsetStack = resetOffsetStack;\nfunction track(segments, stacks = []) {\n    return [\n        new Proxy(segments, {\n            get(target, prop, receiver) {\n                if (tracking) {\n                    if (prop === 'push')\n                        return push;\n                    if (prop === 'pop')\n                        return pop;\n                    if (prop === 'shift')\n                        return shift;\n                    if (prop === 'unshift')\n                        return unshift;\n                    if (prop === 'splice')\n                        return splice;\n                    if (prop === 'sort')\n                        return sort;\n                    if (prop === 'reverse')\n                        return reverse;\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        }),\n        stacks,\n    ];\n    function push(...items) {\n        stacks.push({ stack: getStack(), length: items.length });\n        return segments.push(...items);\n    }\n    function pop() {\n        if (stacks.length) {\n            const last = stacks[stacks.length - 1];\n            if (last.length > 1) {\n                last.length--;\n            }\n            else {\n                stacks.pop();\n            }\n        }\n        return segments.pop();\n    }\n    function shift() {\n        if (stacks.length) {\n            const first = stacks[0];\n            if (first.length > 1) {\n                first.length--;\n            }\n            else {\n                stacks.shift();\n            }\n        }\n        return segments.shift();\n    }\n    function unshift(...items) {\n        stacks.unshift({ stack: getStack(), length: items.length });\n        return segments.unshift(...items);\n    }\n    function splice(start, deleteCount, ...items) {\n        if (deleteCount === undefined) {\n            deleteCount = segments.length - start;\n        }\n        let _stackStart = 0;\n        let operateIndex;\n        for (let i = 0; i < stacks.length; i++) {\n            const stack = stacks[i];\n            const stackStart = _stackStart;\n            const stackEnd = stackStart + stack.length;\n            _stackStart = stackEnd;\n            if (start >= stackStart) {\n                operateIndex = i + 1;\n                const originalLength = stack.length;\n                stack.length = start - stackStart;\n                stacks.splice(operateIndex, 0, { stack: stack.stack, length: originalLength - stack.length });\n                break;\n            }\n        }\n        if (operateIndex === undefined) {\n            throw new Error('Invalid splice operation');\n        }\n        let _deleteCount = deleteCount;\n        for (let i = operateIndex; i < stacks.length; i++) {\n            const stack = stacks[i];\n            while (_deleteCount > 0 && stack.length > 0) {\n                stack.length--;\n                _deleteCount--;\n            }\n            if (_deleteCount === 0) {\n                break;\n            }\n        }\n        stacks.splice(operateIndex, 0, { stack: getStack(), length: items.length });\n        return segments.splice(start, deleteCount, ...items);\n    }\n    function sort(compareFn) {\n        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });\n        return segments.sort(compareFn);\n    }\n    function reverse() {\n        stacks.splice(0, stacks.length, { stack: getStack(), length: segments.length });\n        return segments.reverse();\n    }\n}\nexports.track = track;\nfunction getStack() {\n    const stack = new Error().stack;\n    let source = stack.split('\\n')[3 + stackOffset].trim();\n    if (source.endsWith(')')) {\n        source = source.slice(source.lastIndexOf('(') + 1, -1);\n    }\n    else {\n        source = source.slice(source.lastIndexOf(' ') + 1);\n    }\n    return source;\n}\nexports.getStack = getStack;\n//# sourceMappingURL=track.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.replaceRange = exports.replaceSourceRange = exports.replaceAll = exports.replace = exports.create = exports.toString = exports.getLength = void 0;\nconst binarySearch_1 = require(\"./binarySearch\");\nconst track_1 = require(\"./track\");\n__exportStar(require(\"./types\"), exports);\n__exportStar(require(\"./track\"), exports);\nfunction getLength(segments) {\n    let length = 0;\n    for (const segment of segments) {\n        length += typeof segment == 'string' ? segment.length : segment[0].length;\n    }\n    return length;\n}\nexports.getLength = getLength;\nfunction toString(segments) {\n    return segments.map(s => typeof s === 'string' ? s : s[0]).join('');\n}\nexports.toString = toString;\nfunction create(source) {\n    return [[source, undefined, 0]];\n}\nexports.create = create;\nfunction replace(segments, pattern, ...replacers) {\n    const str = toString(segments);\n    const match = str.match(pattern);\n    if (match && match.index !== undefined) {\n        const startOffset = match.index;\n        const endOffset = startOffset + match[0].length;\n        (0, track_1.offsetStack)();\n        replaceRange(segments, startOffset, endOffset, ...replacers.map(replacer => typeof replacer === 'function' ? replacer(match[0]) : replacer));\n        (0, track_1.resetOffsetStack)();\n    }\n}\nexports.replace = replace;\nfunction replaceAll(segments, pattern, ...replacers) {\n    const str = toString(segments);\n    const allMatch = str.matchAll(pattern);\n    let length = str.length;\n    let lengthDiff = 0;\n    for (const match of allMatch) {\n        if (match.index !== undefined) {\n            const startOffset = match.index + lengthDiff;\n            const endOffset = startOffset + match[0].length;\n            (0, track_1.offsetStack)();\n            replaceRange(segments, startOffset, endOffset, ...replacers.map(replacer => typeof replacer === 'function' ? replacer(match[0]) : replacer));\n            (0, track_1.resetOffsetStack)();\n            const newLength = getLength(segments);\n            lengthDiff += newLength - length;\n            length = newLength;\n        }\n    }\n}\nexports.replaceAll = replaceAll;\nfunction replaceSourceRange(segments, source, startOffset, endOffset, ...newSegments) {\n    for (const segment of segments) {\n        if (typeof segment === 'string') {\n            continue;\n        }\n        if (segment[1] === source) {\n            const segmentStart = segment[2];\n            const segmentEnd = segment[2] + segment[0].length;\n            if (segmentStart <= startOffset && segmentEnd >= endOffset) {\n                const inserts = [];\n                if (startOffset > segmentStart) {\n                    inserts.push(trimSegmentEnd(segment, startOffset - segmentStart));\n                }\n                for (const newSegment of newSegments) {\n                    inserts.push(newSegment);\n                }\n                if (endOffset < segmentEnd) {\n                    inserts.push(trimSegmentStart(segment, endOffset - segmentEnd));\n                }\n                combineStrings(inserts);\n                (0, track_1.offsetStack)();\n                segments.splice(segments.indexOf(segment), 1, ...inserts);\n                (0, track_1.resetOffsetStack)();\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.replaceSourceRange = replaceSourceRange;\nfunction replaceRange(segments, startOffset, endOffset, ...newSegments) {\n    const offsets = toOffsets(segments);\n    const startIndex = (0, binarySearch_1.binarySearch)(offsets, startOffset);\n    const endIndex = (0, binarySearch_1.binarySearch)(offsets, endOffset);\n    const startSegment = segments[startIndex];\n    const endSegment = segments[endIndex];\n    const startSegmentStart = offsets[startIndex];\n    const endSegmentStart = offsets[endIndex];\n    const endSegmentEnd = offsets[endIndex] + (typeof endSegment === 'string' ? endSegment.length : endSegment[0].length);\n    const inserts = [];\n    if (startOffset > startSegmentStart) {\n        inserts.push(trimSegmentEnd(startSegment, startOffset - startSegmentStart));\n    }\n    for (const newSegment of newSegments) {\n        inserts.push(newSegment);\n    }\n    if (endOffset < endSegmentEnd) {\n        inserts.push(trimSegmentStart(endSegment, endOffset - endSegmentStart));\n    }\n    combineStrings(inserts);\n    (0, track_1.offsetStack)();\n    segments.splice(startIndex, endIndex - startIndex + 1, ...inserts);\n    (0, track_1.resetOffsetStack)();\n}\nexports.replaceRange = replaceRange;\nfunction combineStrings(segments) {\n    for (let i = segments.length - 1; i >= 1; i--) {\n        if (typeof segments[i] === 'string' && typeof segments[i - 1] === 'string') {\n            segments[i - 1] = segments[i - 1] + segments[i];\n            (0, track_1.offsetStack)();\n            segments.splice(i, 1);\n            (0, track_1.resetOffsetStack)();\n        }\n    }\n}\nfunction trimSegmentEnd(segment, trimEnd) {\n    if (typeof segment === 'string') {\n        return segment.slice(0, trimEnd);\n    }\n    return [\n        segment[0].slice(0, trimEnd),\n        ...segment.slice(1),\n    ];\n}\nfunction trimSegmentStart(segment, trimStart) {\n    if (typeof segment === 'string') {\n        return segment.slice(trimStart);\n    }\n    if (trimStart < 0) {\n        trimStart += segment[0].length;\n    }\n    return [\n        segment[0].slice(trimStart),\n        segment[1],\n        segment[2] + trimStart,\n        ...segment.slice(3),\n    ];\n}\nfunction toOffsets(segments) {\n    const offsets = [];\n    let offset = 0;\n    for (const segment of segments) {\n        offsets.push(offset);\n        offset += typeof segment == 'string' ? segment.length : segment[0].length;\n    }\n    return offsets;\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.binarySearch = void 0;\nfunction binarySearch(values, searchValue) {\n    let low = 0;\n    let high = values.length - 1;\n    let match;\n    while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const midValue = values[mid];\n        if (midValue < searchValue) {\n            low = mid + 1;\n        }\n        else if (midValue > searchValue) {\n            high = mid - 1;\n        }\n        else {\n            low = mid;\n            high = mid;\n            match = mid;\n            break;\n        }\n    }\n    const finalLow = Math.max(Math.min(low, high, values.length - 1), 0);\n    const finalHigh = Math.min(Math.max(low, high, 0), values.length - 1);\n    return { low: finalLow, high: finalHigh, match };\n}\nexports.binarySearch = binarySearch;\n//# sourceMappingURL=binarySearch.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.translateOffset = void 0;\nfunction translateOffset(start, fromOffsets, toOffsets, lengths) {\n    for (let i = 0; i < fromOffsets.length; i++) {\n        const fromOffset = fromOffsets[i];\n        const toOffset = toOffsets[i];\n        const length = lengths[i];\n        if (start >= fromOffset && start <= fromOffset + length) {\n            return toOffset + start - fromOffset;\n        }\n    }\n}\nexports.translateOffset = translateOffset;\n//# sourceMappingURL=translateOffset.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceMap = void 0;\nconst binarySearch_1 = require(\"./binarySearch\");\nconst translateOffset_1 = require(\"./translateOffset\");\nclass SourceMap {\n    constructor(mappings) {\n        this.mappings = mappings;\n    }\n    getSourceOffset(generatedOffset) {\n        for (const mapped of this.findMatching(generatedOffset, 'generatedOffsets', 'sourceOffsets')) {\n            return mapped;\n        }\n    }\n    getGeneratedOffset(sourceOffset) {\n        for (const mapped of this.findMatching(sourceOffset, 'sourceOffsets', 'generatedOffsets')) {\n            return mapped;\n        }\n    }\n    getSourceOffsets(generatedOffset) {\n        return this.findMatching(generatedOffset, 'generatedOffsets', 'sourceOffsets');\n    }\n    getGeneratedOffsets(sourceOffset) {\n        return this.findMatching(sourceOffset, 'sourceOffsets', 'generatedOffsets');\n    }\n    *findMatching(offset, fromRange, toRange) {\n        const memo = this.getMemoBasedOnRange(fromRange);\n        if (memo.offsets.length === 0) {\n            return;\n        }\n        const { low: start, high: end } = (0, binarySearch_1.binarySearch)(memo.offsets, offset);\n        const skip = new Set();\n        for (let i = start; i <= end; i++) {\n            for (const mapping of memo.mappings[i]) {\n                if (skip.has(mapping)) {\n                    continue;\n                }\n                skip.add(mapping);\n                const mapped = (0, translateOffset_1.translateOffset)(offset, mapping[fromRange], mapping[toRange], mapping.lengths);\n                if (mapped !== undefined) {\n                    yield [mapped, mapping];\n                }\n            }\n        }\n    }\n    getMemoBasedOnRange(fromRange) {\n        return fromRange === 'sourceOffsets'\n            ? this.sourceCodeOffsetsMemo ??= this.createMemo('sourceOffsets')\n            : this.generatedCodeOffsetsMemo ??= this.createMemo('generatedOffsets');\n    }\n    createMemo(key) {\n        const offsetsSet = new Set();\n        for (const mapping of this.mappings) {\n            for (let i = 0; i < mapping[key].length; i++) {\n                offsetsSet.add(mapping[key][i]);\n                offsetsSet.add(mapping[key][i] + mapping.lengths[i]);\n            }\n        }\n        const offsets = [...offsetsSet].sort((a, b) => a - b);\n        const mappings = offsets.map(() => new Set());\n        for (const mapping of this.mappings) {\n            for (let i = 0; i < mapping[key].length; i++) {\n                const startIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i]).match;\n                const endIndex = (0, binarySearch_1.binarySearch)(offsets, mapping[key][i] + mapping.lengths[i]).match;\n                for (let i = startIndex; i <= endIndex; i++) {\n                    mappings[i].add(mapping);\n                }\n            }\n        }\n        return { offsets, mappings };\n    }\n}\nexports.SourceMap = SourceMap;\n//# sourceMappingURL=sourceMap.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildMappings = void 0;\nfunction buildMappings(chunks) {\n    let length = 0;\n    const mappings = [];\n    for (const segment of chunks) {\n        if (typeof segment === 'string') {\n            length += segment.length;\n        }\n        else {\n            mappings.push({\n                source: segment[1],\n                sourceOffsets: [segment[2]],\n                generatedOffsets: [length],\n                lengths: [segment[0].length],\n                data: segment[3],\n            });\n            length += segment[0].length;\n        }\n    }\n    return mappings;\n}\nexports.buildMappings = buildMappings;\n//# sourceMappingURL=buildMappings.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildStacks = void 0;\nfunction buildStacks(chunks, stacks) {\n    let offset = 0;\n    let index = 0;\n    const result = [];\n    for (const stack of stacks) {\n        const start = offset;\n        for (let i = 0; i < stack.length; i++) {\n            const segment = chunks[index + i];\n            if (typeof segment === 'string') {\n                offset += segment.length;\n            }\n            else {\n                offset += segment[0].length;\n            }\n        }\n        index += stack.length;\n        result.push({\n            source: stack.stack,\n            range: [start, offset],\n        });\n    }\n    return result;\n}\nexports.buildStacks = buildStacks;\n//# sourceMappingURL=buildStacks.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"muggle-string\"), exports);\n__exportStar(require(\"./lib/sourceMap\"), exports);\n__exportStar(require(\"./lib/translateOffset\"), exports);\n__exportStar(require(\"./lib/buildMappings\"), exports);\n__exportStar(require(\"./lib/buildStacks\"), exports);\n//# sourceMappingURL=index.js.map","import type * as ts from 'typescript';\nimport { SourceMap } from '@volar/source-map';\nimport type { Project } from 'ts-morph';\n\nimport type { AsyncCreateVirtualCode, TranslatePosition } from './types';\nimport { scanProjectFiles } from './scan';\n\nlet _svelte: typeof import('./svelte') | undefined;\nlet _vue: typeof import('./vue') | undefined;\n\nconst svelte = async () => _svelte || (_svelte = await import('./svelte'));\nconst vue = async () => _vue || (_vue = await import('./vue'));\n\nconst VIRTUAL_EXT = '.ts';\n\nconst getVirtualType = (filepath: string): 'vue' | 'svelte' | undefined => {\n  if (filepath.endsWith('.vue')) {\n    return 'vue';\n  } else if (filepath.endsWith('.svelte')) {\n    return 'svelte';\n  }\n};\n\nconst createVirtualCode: AsyncCreateVirtualCode = async (fileId, snapshot, ts) => {\n  const type = getVirtualType(fileId);\n  if (type === 'vue') {\n    return (await vue()).createVirtualCode(fileId, snapshot, ts);\n  } else if (type === 'svelte') {\n    return (await svelte()).createVirtualCode(fileId, snapshot, ts);\n  }\n};\n\nexport * from './types';\n\nexport const loadVirtualCode = async (\n  projectPath: string,\n  project: Project,\n  ts: typeof import('typescript/lib/tsserverlibrary')\n): Promise<TranslatePosition | undefined> => {\n  const projectFiles = await scanProjectFiles(\n    [projectPath, ...project.getRootDirectories().map((path) => path.getPath())],\n    (filepath) => !!getVirtualType(filepath),\n    ts\n  );\n\n  if (!projectFiles.length) return undefined;\n\n  const projectToVirtual = new Map<string, ts.SourceFile>();\n  const virtualToProject = new Map<string, ts.SourceFile>();\n  const sourceMaps = new Map<string, SourceMap>();\n\n  for (const file of projectFiles) {\n    const projectSourceFile = ts.createSourceFile(\n      file.fileId,\n      file.snapshot.getText(0, file.snapshot.getLength()),\n      ts.ScriptTarget.ESNext,\n      false,\n      ts.ScriptKind.External\n    );\n\n    const virtualCode = await createVirtualCode(file.fileId, file.snapshot, ts);\n    const virtualSnapshot = virtualCode && virtualCode.snapshot;\n    if (!virtualCode || !virtualSnapshot) continue;\n\n    const sourceMap = new SourceMap(virtualCode.mappings);\n    const virtualFileId = file.fileId + VIRTUAL_EXT;\n    const virtualSourceFile = project.createSourceFile(\n      virtualFileId,\n      virtualSnapshot.getText(0, virtualSnapshot.getLength()),\n      { overwrite: true, scriptKind: ts.ScriptKind.TSX }\n    );\n\n    if (virtualSourceFile._markAsInProject) virtualSourceFile._markAsInProject();\n\n    projectToVirtual.set(file.fileId, virtualSourceFile.compilerNode);\n    virtualToProject.set(virtualFileId, projectSourceFile);\n    sourceMaps.set(file.fileId, sourceMap);\n    sourceMaps.set(virtualFileId, sourceMap);\n  }\n\n  return ((fileId, position) => {\n    let sourceFile: ts.SourceFile | undefined;\n    let sourceMap: SourceMap | undefined;\n    if ((sourceFile = projectToVirtual.get(fileId)) && (sourceMap = sourceMaps.get(fileId))) {\n      const generatedPosition = position != null ? sourceMap.getGeneratedOffset(position) : null;\n      return {\n        fileId: sourceFile.fileName,\n        file: sourceFile,\n        position: generatedPosition ? generatedPosition[0] : position || 0,\n        isVirtual: true,\n      };\n    } else if (\n      (sourceFile = virtualToProject.get(fileId)) &&\n      (sourceMap = sourceMaps.get(fileId))\n    ) {\n      const sourcePosition = position != null ? sourceMap.getSourceOffset(position) : null;\n      return {\n        fileId: sourceFile.fileName,\n        file: sourceFile,\n        position: sourcePosition ? sourcePosition[0] : position || 0,\n        isVirtual: false,\n      };\n    }\n  }) satisfies TranslatePosition;\n};\n","import type { WorkerOptions } from 'node:worker_threads';\nimport { Worker, isMainThread, parentPort, SHARE_ENV } from 'node:worker_threads';\n\nconst port = parentPort!;\nif (!isMainThread && !port) {\n  throw new ReferenceError('Failed to receive parent message port');\n}\n\nconst enum MainMessageCodes {\n  Start = 'START',\n  Close = 'CLOSE',\n  Pull = 'PULL',\n}\n\ninterface MainMessage {\n  id?: number;\n  kind: MainMessageCodes;\n  data?: any;\n}\n\nconst enum ThreadMessageCodes {\n  Next = 'NEXT',\n  Throw = 'THROW',\n  Return = 'RETURN',\n}\n\ninterface ThreadMessage {\n  id?: number;\n  kind: ThreadMessageCodes;\n  data?: any;\n}\n\nconst workerOpts: WorkerOptions = {\n  env: SHARE_ENV,\n  stderr: false,\n  stdout: false,\n  stdin: false,\n};\n\nconst asyncIteratorSymbol = (): typeof Symbol.asyncIterator =>\n  (typeof Symbol === 'function' && Symbol.asyncIterator) || ('@@asyncIterator' as any);\n\n/** Capture the stack above the caller */\nfunction captureStack(): NodeJS.CallSite[] {\n  const _error: any = new Error();\n  const _prepareStackTrace = Error.prepareStackTrace;\n  try {\n    let stack: NodeJS.CallSite[] | undefined;\n    Error.prepareStackTrace = (_error, _stack) => (stack = _stack);\n    Error.captureStackTrace(_error);\n    if (!_error.stack) throw _error;\n    return (stack && stack.slice(2)) || [];\n  } finally {\n    Error.prepareStackTrace = _prepareStackTrace;\n  }\n}\n\nexport interface Generator<Args extends readonly any[], Next> {\n  // TODO: Update to support for AsyncGenerator interface\n  (...args: Args): AsyncIterableIterator<Next>;\n}\n\nfunction main<Args extends readonly any[], Next>(url: string | URL): Generator<Args, Next> {\n  let worker: Worker;\n  let ids = 0;\n  return (...args: Args) => {\n    if (!worker) {\n      worker = new Worker(url, workerOpts);\n      worker.unref();\n    }\n\n    const id = ++ids | 0;\n    const buffer: ThreadMessage[] = [];\n\n    let started = false;\n    let ended = false;\n    let pulled = false;\n    let resolve: ((value: IteratorResult<Next>) => void) | void;\n    let reject: ((error: any) => void) | void;\n\n    function cleanup() {\n      ended = true;\n      resolve = undefined;\n      reject = undefined;\n      worker.removeListener('message', receiveMessage);\n      worker.removeListener('error', receiveError);\n    }\n\n    function sendMessage(kind: MainMessageCodes) {\n      worker.postMessage({ id, kind });\n    }\n\n    function receiveError(error: any) {\n      cleanup();\n      buffer.length = 1;\n      buffer[0] = {\n        id,\n        kind: ThreadMessageCodes.Throw,\n        data: error,\n      };\n    }\n\n    function receiveMessage(data: unknown) {\n      const message: ThreadMessage | null =\n        data && typeof data === 'object' && 'kind' in data ? (data as ThreadMessage) : null;\n      if (!message) {\n        return;\n      } else if (reject && message.kind === ThreadMessageCodes.Throw) {\n        reject(message.data);\n        cleanup();\n      } else if (resolve && message.kind === ThreadMessageCodes.Return) {\n        resolve({ done: true, value: message.data });\n        cleanup();\n      } else if (resolve && message.kind === ThreadMessageCodes.Next) {\n        pulled = false;\n        resolve({ done: false, value: message.data });\n      } else if (\n        message.kind === ThreadMessageCodes.Throw ||\n        message.kind === ThreadMessageCodes.Return\n      ) {\n        buffer.push(message);\n        cleanup();\n      } else if (message.kind === ThreadMessageCodes.Next) {\n        buffer.push(message);\n        pulled = false;\n      }\n    }\n\n    return {\n      async next() {\n        if (!started) {\n          started = true;\n          worker.addListener('message', receiveMessage);\n          worker.addListener('error', receiveError);\n          worker.postMessage({\n            id,\n            kind: MainMessageCodes.Start,\n            data: args,\n          });\n        }\n        if (ended && !buffer.length) {\n          return { done: true } as IteratorReturnResult<any>;\n        } else if (!ended && !pulled && buffer.length <= 1) {\n          pulled = true;\n          sendMessage(MainMessageCodes.Pull);\n        }\n        const message = buffer.shift();\n        if (message && message.kind === ThreadMessageCodes.Throw) {\n          cleanup();\n          throw message.data;\n        } else if (message && message.kind === ThreadMessageCodes.Return) {\n          cleanup();\n          return { value: message.data, done: true };\n        } else if (message && message.kind === ThreadMessageCodes.Next) {\n          return { value: message.data, done: false };\n        } else {\n          return new Promise((_resolve, _reject) => {\n            resolve = (value) => {\n              resolve = undefined;\n              reject = undefined;\n              _resolve(value);\n            };\n            reject = (error) => {\n              resolve = undefined;\n              reject = undefined;\n              _reject(error);\n            };\n          });\n        }\n      },\n      async return() {\n        if (!ended) {\n          cleanup();\n          sendMessage(MainMessageCodes.Close);\n        }\n        return { done: true } as IteratorReturnResult<any>;\n      },\n      [asyncIteratorSymbol()]() {\n        return this;\n      },\n    };\n  };\n}\n\nfunction thread<Args extends readonly any[], Next>(\n  message: MainMessage,\n  generator: Generator<Args, Next>\n): void {\n  if (message.kind !== MainMessageCodes.Start) return;\n  const id = message.id;\n  const iterator = generator(...(message.data as any));\n\n  let ended = false;\n  let pulled = false;\n  let looping = false;\n\n  function cleanup() {\n    ended = true;\n    port.removeListener('message', receiveMessage);\n  }\n\n  async function sendMessage(kind: ThreadMessageCodes, data?: any) {\n    try {\n      port.postMessage({ id, kind, data });\n    } catch (error) {\n      cleanup();\n      if (iterator.throw) {\n        let result = await iterator.throw();\n        if (result.done === false && iterator.return) {\n          result = await iterator.return();\n          sendMessage(ThreadMessageCodes.Return, result.value);\n        } else {\n          sendMessage(ThreadMessageCodes.Return, result.value);\n        }\n      } else {\n        sendMessage(ThreadMessageCodes.Return);\n      }\n    }\n  }\n\n  async function receiveMessage(data: unknown) {\n    const message: MainMessage | null =\n      data && typeof data === 'object' && 'kind' in data ? (data as MainMessage) : null;\n    let next: IteratorResult<Next>;\n    if (!message) {\n      return;\n    } else if (message.kind === MainMessageCodes.Close) {\n      cleanup();\n      if (iterator.return) iterator.return();\n    } else if (message.kind === MainMessageCodes.Pull && looping) {\n      pulled = true;\n    } else if (message.kind === MainMessageCodes.Pull) {\n      for (pulled = looping = true; pulled && !ended; ) {\n        try {\n          if ((next = await iterator.next()).done) {\n            cleanup();\n            if (iterator.return) next = await iterator.return();\n            sendMessage(ThreadMessageCodes.Return, next.value);\n          } else {\n            pulled = false;\n            sendMessage(ThreadMessageCodes.Next, next.value);\n          }\n        } catch (error) {\n          cleanup();\n          sendMessage(ThreadMessageCodes.Throw, error);\n        }\n      }\n      looping = false;\n    }\n  }\n\n  port.addListener('message', receiveMessage);\n}\n\nexport function expose<Args extends readonly any[], Return>(\n  generator: Generator<Args, Return>\n): Generator<Args, Return> {\n  if (isMainThread) {\n    const call = captureStack()[0];\n    const file = call && call.getFileName();\n    if (!file) throw new ReferenceError('Captured stack trace is empty');\n    const url = file.startsWith('file://') ? new URL(file) : file;\n    return main(url);\n  } else {\n    port.addListener('message', (data) => {\n      const message: MainMessage | null =\n        data && typeof data === 'object' && 'kind' in data ? (data as MainMessage) : null;\n      if (message) thread(message, generator);\n    });\n    return generator;\n  }\n}\n","import type { SourceFile } from 'typescript';\nimport type { TranslatePosition, FilePosition } from './virtualCode';\n\nexport interface Position {\n  file: string;\n  line: number;\n  col: number;\n  endLine: number | undefined;\n  endColumn: number | undefined;\n}\n\nexport const getFilePosition = (\n  file: SourceFile,\n  start?: number | undefined,\n  length?: number | undefined,\n  getVirtualPosition?: TranslatePosition\n): Position => {\n  const output: Position = {\n    file: file.fileName,\n    line: 1,\n    col: 1,\n    endLine: undefined,\n    endColumn: undefined,\n  };\n\n  let end = start != null && length != null ? start + length - 1 : undefined;\n  if (getVirtualPosition) {\n    let originalPosition: FilePosition | undefined;\n    if (\n      (originalPosition = getVirtualPosition(file.fileName, start)) &&\n      !originalPosition.isVirtual\n    ) {\n      output.file = originalPosition.fileId;\n      file = originalPosition.file;\n      start = originalPosition.position;\n      if (end != null && (originalPosition = getVirtualPosition(file.fileName, end))) {\n        end = originalPosition.position;\n      }\n    }\n  }\n\n  if (start) {\n    let lineAndChar = file.getLineAndCharacterOfPosition(start);\n    output.line = lineAndChar.line + 1;\n    output.col = lineAndChar.character + 1;\n    if (end != null) {\n      lineAndChar = file.getLineAndCharacterOfPosition(end);\n      output.endLine = lineAndChar.line + 1;\n      output.endColumn = lineAndChar.character + 1;\n    }\n  }\n\n  return output;\n};\n","import type { IScriptSnapshot } from 'typescript';\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nexport interface ScannedFile {\n  fileId: string;\n  snapshot: IScriptSnapshot;\n}\n\nexport async function scanProjectFiles(\n  paths: readonly string[],\n  predicate: (filepath: string) => boolean,\n  ts: typeof import('typescript/lib/tsserverlibrary')\n): Promise<readonly ScannedFile[]> {\n  const seenPaths = new Set();\n  const searchPaths = [...paths];\n  const files: ScannedFile[] = [];\n\n  async function _scanVueFile(filepath: string, origpath?: string) {\n    const stat = await fs.stat(filepath);\n    if (stat.isSymbolicLink()) {\n      if (!origpath) await _scanVueFile(await fs.realpath(filepath), filepath);\n    } else if (stat.isFile()) {\n      if (predicate(origpath || filepath)) {\n        const contents = await fs.readFile(filepath, 'utf8');\n        files.push({\n          fileId: filepath,\n          snapshot: ts.ScriptSnapshot.fromString(contents),\n        });\n      }\n    } else if (stat.isDirectory() && !/\\bnode_modules\\b/.test(filepath)) {\n      if (!seenPaths.has(filepath)) searchPaths.push(filepath);\n    }\n  }\n\n  async function _scanVueFiles(dirpath: string) {\n    if (seenPaths.has(dirpath)) return;\n    seenPaths.add(dirpath);\n\n    let dir: string[];\n    try {\n      dir = await fs.readdir(dirpath);\n    } catch (_error) {\n      return;\n    }\n\n    for (const entry of dir) {\n      const filepath = path.join(dirpath, entry);\n      try {\n        await _scanVueFile(filepath);\n      } catch (_error) {\n        continue;\n      }\n    }\n  }\n\n  let dir: string | undefined;\n  while ((dir = searchPaths.shift()) != null) await _scanVueFiles(dir);\n  return files;\n}\n"],"names":["Object","defineProperty","binarySearch_1","value","binarySearch","offsets","start","low","high","length","mid","Math","floor","midValue","max","min","track_1","getStack","track","resetOffsetStack","offsetStack","setTracking","tracking","stackOffset","segments","stacks","Proxy","get","target","prop","receiver","push","pop","shift","unshift","splice","sort","reverse","Reflect","items","stack","last","first","deleteCount","undefined","_stackStart","operateIndex","i","stackStart","originalLength","Error","_deleteCount","compareFn","source","split","trim","endsWith","slice","lastIndexOf","types","__createBinding","this","create","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","__exportStar","exports","p","prototype","hasOwnProperty","call","replaceRange","replaceSourceRange","replace","getLength","require$$0","require$$1","require$$2","segment","toString","map","s","join","pattern","replacers","match","index","startOffset","endOffset","replacer","replaceAll","str","allMatch","matchAll","lengthDiff","_loop","newLength","newSegments","segmentStart","segmentEnd","inserts","trimSegmentEnd","newSegment","trimSegmentStart","combineStrings","indexOf","toOffsets","offset","startIndex","endIndex","endSegment","startSegmentStart","endSegmentStart","endSegmentEnd","trimEnd","trimStart","values","searchValue","translateOffset_1","translateOffset","fromOffsets","lengths","fromOffset","sourceMap","SourceMap","constructor","mappings","getSourceOffset","generatedOffset","mapped","findMatching","getGeneratedOffset","sourceOffset","getSourceOffsets","getGeneratedOffsets","fromRange","toRange","memo","getMemoBasedOnRange","end","skip","Set","mapping","has","add","sourceCodeOffsetsMemo","createMemo","generatedCodeOffsetsMemo","key","offsetsSet","a","b","buildMappings_1","buildMappings","chunks","sourceOffsets","generatedOffsets","data","buildStacks_1","buildStacks","result","range","require$$3","require$$4","_svelte","_vue","getVirtualType","filepath","createVirtualCode","async","fileId","snapshot","ts","type","Promise","resolve","then","require","vue","svelte","port","parentPort","isMainThread","ReferenceError","MainMessageCodes","ThreadMessageCodes","workerOpts","env","SHARE_ENV","stderr","stdout","stdin","asyncIteratorSymbol","Symbol","asyncIterator","expose","generator","captureStack","_error","_prepareStackTrace","prepareStackTrace","_stack","captureStackTrace","file","getFileName","main","url","worker","ids","args","Worker","unref","id","buffer","started","ended","pulled","reject","cleanup","removeListener","receiveMessage","receiveError","sendMessage","kind","postMessage","error","Throw","message","Return","done","Next","next","addListener","Start","Pull","_resolve","_reject","return","Close","startsWith","URL","thread","iterator","looping","throw","getFilePosition","getVirtualPosition","output","fileName","line","col","endLine","endColumn","originalPosition","isVirtual","position","lineAndChar","getLineAndCharacterOfPosition","character","projectPath","project","projectFiles","scanProjectFiles","paths","predicate","seenPaths","searchPaths","files","_scanVueFile","origpath","stat","fs","isSymbolicLink","realpath","isFile","contents","readFile","ScriptSnapshot","fromString","isDirectory","test","_scanVueFiles","dirpath","dir","readdir","entry","path","getRootDirectories","getPath","projectToVirtual","Map","virtualToProject","sourceMaps","projectSourceFile","createSourceFile","getText","ScriptTarget","ESNext","ScriptKind","External","virtualCode","virtualSnapshot","virtualFileId","virtualSourceFile","overwrite","scriptKind","TSX","_markAsInProject","set","compilerNode","sourceFile","generatedPosition","sourcePosition"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}